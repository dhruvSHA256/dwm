dwm.c:	c->noswallow = -1;
dwm.c:	c->isfloating = 0;
dwm.c:	c->tags = 0;
dwm.c:	XGetClassHint(dpy, c->win, &ch);
dwm.c:		if ((!r->title || strstr(c->name, r->title))
dwm.c:			c->isterminal = r->isterminal;
dwm.c:			c->noswallow  = r->noswallow;
dwm.c:			c->isfloating = r->isfloating;
dwm.c:			c->tags |= r->tags;
dwm.c:				c->mon = m;
dwm.c:	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : c->mon->tagset[c->mon->seltags];
dwm.c:	Monitor *m = c->mon;
dwm.c:		if (*x + *w + 2 * c->bw < 0)
dwm.c:		if (*y + *h + 2 * c->bw < 0)
dwm.c:		if (*x + *w + 2 * c->bw <= m->wx)
dwm.c:		if (*y + *h + 2 * c->bw <= m->wy)
dwm.c:	if (resizehints || c->isfloating || !c->mon->lt[c->mon->sellt]->arrange) {
dwm.c:		baseismin = c->basew == c->minw && c->baseh == c->minh;
dwm.c:			*w -= c->basew;
dwm.c:			*h -= c->baseh;
dwm.c:		if (c->mina > 0 && c->maxa > 0) {
dwm.c:			if (c->maxa < (float)*w / *h)
dwm.c:				*w = *h * c->maxa + 0.5;
dwm.c:			else if (c->mina < (float)*h / *w)
dwm.c:				*h = *w * c->mina + 0.5;
dwm.c:			*w -= c->basew;
dwm.c:			*h -= c->baseh;
dwm.c:		if (c->incw)
dwm.c:			*w -= *w % c->incw;
dwm.c:		if (c->inch)
dwm.c:			*h -= *h % c->inch;
dwm.c:		*w = MAX(*w + c->basew, c->minw);
dwm.c:		*h = MAX(*h + c->baseh, c->minh);
dwm.c:		if (c->maxw)
dwm.c:			*w = MIN(*w, c->maxw);
dwm.c:		if (c->maxh)
dwm.c:			*h = MIN(*h, c->maxh);
dwm.c:	return *x != c->x || *y != c->y || *w != c->w || *h != c->h;
dwm.c:	c->next = c->mon->clients;
dwm.c:	c->mon->clients = c;
dwm.c:	c->snext = c->mon->stack;
dwm.c:	c->mon->stack = c;
dwm.c:	if (c->noswallow > 0 || c->isterminal)
dwm.c:	if (c->noswallow < 0 && !swallowfloating && c->isfloating)
dwm.c:	c->mon = p->mon;
dwm.c:	p->win = c->win;
dwm.c:	c->win = w;
dwm.c:	XChangeProperty(dpy, c->win, netatom[NetClientList], XA_WINDOW, 32, PropModeReplace,
dwm.c:	c->win = c->swallowing->win;
dwm.c:	free(c->swallowing);
dwm.c:	c->swallowing = NULL;
dwm.c:	XDeleteProperty(dpy, c->win, netatom[NetClientList]);
dwm.c:	arrange(c->mon);
dwm.c:	XMapWindow(dpy, c->win);
dwm.c:	XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
dwm.c:	arrange(c->mon);
dwm.c:		for (c = m->clients; c; c = c->next)
dwm.c:			occ |= c->tags == 255 ? 0 : c->tags;
dwm.c:				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
dwm.c:		if (c != selmon->sel && !c->isurgent)
dwm.c:	ce.event = c->win;
dwm.c:	ce.window = c->win;
dwm.c:	ce.x = c->x;
dwm.c:	ce.y = c->y;
dwm.c:	ce.width = c->w;
dwm.c:	ce.height = c->h;
dwm.c:	ce.border_width = c->bw;
dwm.c:	XSendEvent(dpy, c->win, False, StructureNotifyMask, (XEvent *)&ce);
dwm.c:				for (c = m->clients; c; c = c->next)
dwm.c:					if (c->isfullscreen)
dwm.c:			c->bw = ev->border_width;
dwm.c:		else if (c->isfloating || !selmon->lt[selmon->sellt]->arrange) {
dwm.c:			m = c->mon;
dwm.c:				c->oldx = c->x;
dwm.c:				c->x = m->mx + ev->x;
dwm.c:				c->oldy = c->y;
dwm.c:				c->y = m->my + ev->y;
dwm.c:				c->oldw = c->w;
dwm.c:				c->w = ev->width;
dwm.c:				c->oldh = c->h;
dwm.c:				c->h = ev->height;
dwm.c:			if ((c->x + c->w) > m->mx + m->mw && c->isfloating)
dwm.c:				c->x = m->mx + (m->mw / 2 - WIDTH(c) / 2); /* center in x direction */
dwm.c:			if ((c->y + c->h) > m->my + m->mh && c->isfloating)
dwm.c:				c->y = m->my + (m->mh / 2 - HEIGHT(c) / 2); /* center in y direction */
dwm.c:				XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
dwm.c:		unmanage(c->swallowing, 1);
dwm.c:	for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
dwm.c:	*tc = c->next;
dwm.c:	for (tc = &c->mon->stack; *tc && *tc != c; tc = &(*tc)->snext);
dwm.c:	*tc = c->snext;
dwm.c:	if (c == c->mon->sel) {
dwm.c:		for (t = c->mon->stack; t && !ISVISIBLE(t); t = t->snext);
dwm.c:		c->mon->sel = t;
dwm.c:	for (c = m->clients; c; c = c->next) {
dwm.c:		occ |= c->tags == 255 ? 0 : c->tags;
dwm.c:		if (c->isurgent)
dwm.c:			urg |= c->tags;
dwm.c:	m = c ? c->mon : wintomon(ev->window);
dwm.c:		for (c = selmon->stack; c && !ISVISIBLE(c); c = c->snext);
dwm.c:		if (c->mon != selmon)
dwm.c:			selmon = c->mon;
dwm.c:		if (c->isurgent)
dwm.c:		XSetWindowBorder(dpy, c->win, scheme[SchemeSel][ColBorder].pixel);
dwm.c:		for (c = selmon->sel->next; c && !ISVISIBLE(c); c = c->next);
dwm.c:			for (c = selmon->clients; c && !ISVISIBLE(c); c = c->next);
dwm.c:	if (XGetWindowProperty(dpy, c->win, prop, 0L, sizeof atom, False, XA_ATOM,
dwm.c:		XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
dwm.c:			XGrabButton(dpy, AnyButton, AnyModifier, c->win, False,
dwm.c:						c->win, False, BUTTONMASK,
dwm.c:	c->win = w;
dwm.c:	c->pid = winpid(w);
dwm.c:	c->x = c->oldx = wa->x;
dwm.c:	c->y = c->oldy = wa->y;
dwm.c:	c->w = c->oldw = wa->width;
dwm.c:	c->h = c->oldh = wa->height;
dwm.c:	c->oldbw = wa->border_width;
dwm.c:		c->mon = t->mon;
dwm.c:		c->tags = t->tags;
dwm.c:		c->mon = selmon;
dwm.c:	if (c->x + WIDTH(c) > c->mon->mx + c->mon->mw)
dwm.c:		c->x = c->mon->mx + c->mon->mw - WIDTH(c);
dwm.c:	if (c->y + HEIGHT(c) > c->mon->my + c->mon->mh)
dwm.c:		c->y = c->mon->my + c->mon->mh - HEIGHT(c);
dwm.c:	c->x = MAX(c->x, c->mon->mx);
dwm.c:	c->y = MAX(c->y, ((c->mon->by == c->mon->my) && (c->x + (c->w / 2) >= c->mon->wx)
dwm.c:		&& (c->x + (c->w / 2) < c->mon->wx + c->mon->ww)) ? bh : c->mon->my);
dwm.c:	c->bw = borderpx;
dwm.c:	wc.border_width = c->bw;
dwm.c:	if (!c->isfloating)
dwm.c:		c->isfloating = c->oldstate = trans != None || c->isfixed;
dwm.c:	if (c->isfloating)
dwm.c:		XRaiseWindow(dpy, c->win);
dwm.c:		(unsigned char *) &(c->win), 1);
dwm.c:	XMoveResizeWindow(dpy, c->win, c->x + 2 * sw, c->y, c->w, c->h); /* some windows require this */
dwm.c:	if (c->mon == selmon)
dwm.c:	c->mon->sel = c;
dwm.c:	arrange(c->mon);
dwm.c:	XMapWindow(dpy, c->win);
dwm.c:	for (c = m->clients; c; c = c->next)
dwm.c:	for (c = nexttiled(m->clients); c; c = nexttiled(c->next))
dwm.c:		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
dwm.c:	if (c->isfullscreen) /* no support moving fullscreen windows by mouse */
dwm.c:	ocx = c->x;
dwm.c:	ocy = c->y;
dwm.c:			if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
dwm.c:			&& (abs(nx - c->x) > snap || abs(ny - c->y) > snap))
dwm.c:			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
dwm.c:				resize(c, nx, ny, c->w, c->h, 1);
dwm.c:	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
dwm.c:	for (; c && (c->isfloating || !ISVISIBLE(c)); c = c->next);
dwm.c:	arrange(c->mon);
dwm.c:			if (!c->isfloating && (XGetTransientForHint(dpy, c->win, &trans)) &&
dwm.c:				(c->isfloating = (wintoclient(trans)) != NULL))
dwm.c:				arrange(c->mon);
dwm.c:			if (c == c->mon->sel)
dwm.c:				drawbar(c->mon);
dwm.c:	c->oldx = c->x; c->x = wc.x = x;
dwm.c:	c->oldy = c->y; c->y = wc.y = y;
dwm.c:	c->oldw = c->w; c->w = wc.width = w;
dwm.c:	c->oldh = c->h; c->h = wc.height = h;
dwm.c:	wc.border_width = c->bw;
dwm.c:	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
dwm.c:	if (c->isfullscreen) /* no support resizing fullscreen windows by mouse */
dwm.c:	ocx = c->x;
dwm.c:	ocy = c->y;
dwm.c:	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
dwm.c:			nw = MAX(ev.xmotion.x - ocx - 2 * c->bw + 1, 1);
dwm.c:			nh = MAX(ev.xmotion.y - ocy - 2 * c->bw + 1, 1);
dwm.c:			if (c->mon->wx + nw >= selmon->wx && c->mon->wx + nw <= selmon->wx + selmon->ww
dwm.c:			&& c->mon->wy + nh >= selmon->wy && c->mon->wy + nh <= selmon->wy + selmon->wh)
dwm.c:				if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
dwm.c:				&& (abs(nw - c->w) > snap || abs(nh - c->h) > snap))
dwm.c:			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
dwm.c:				resize(c, c->x, c->y, nw, nh, 1);
dwm.c:	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
dwm.c:	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
dwm.c:		for (c = m->stack; c; c = c->snext)
dwm.c:			if (!c->isfloating && ISVISIBLE(c)) {
dwm.c:				XConfigureWindow(dpy, c->win, CWSibling|CWStackMode, &wc);
dwm.c:				wc.sibling = c->win;
dwm.c:	if (c->mon == m)
dwm.c:	c->mon = m;
dwm.c:	c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
dwm.c:	XChangeProperty(dpy, c->win, wmatom[WMState], wmatom[WMState], 32,
dwm.c:	if (XGetWMProtocols(dpy, c->win, &protocols, &n)) {
dwm.c:		ev.xclient.window = c->win;
dwm.c:		XSendEvent(dpy, c->win, False, NoEventMask, &ev);
dwm.c:	if (!c->neverfocus) {
dwm.c:		XSetInputFocus(dpy, c->win, RevertToPointerRoot, CurrentTime);
dwm.c:			(unsigned char *) &(c->win), 1);
dwm.c:	if (fullscreen && !c->isfullscreen) {
dwm.c:		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
dwm.c:		c->isfullscreen = 1;
dwm.c:		c->oldstate = c->isfloating;
dwm.c:		c->oldbw = c->bw;
dwm.c:		c->bw = 0;
dwm.c:		c->isfloating = 1;
dwm.c:		resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh);
dwm.c:		XRaiseWindow(dpy, c->win);
dwm.c:	} else if (!fullscreen && c->isfullscreen){
dwm.c:		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
dwm.c:		c->isfullscreen = 0;
dwm.c:		c->isfloating = c->oldstate;
dwm.c:		c->bw = c->oldbw;
dwm.c:		c->x = c->oldx;
dwm.c:		c->y = c->oldy;
dwm.c:		c->w = c->oldw;
dwm.c:		c->h = c->oldh;
dwm.c:		resizeclient(c, c->x, c->y, c->w, c->h);
dwm.c:		arrange(c->mon);
dwm.c:	c->isurgent = urg;
dwm.c:	if (!(wmh = XGetWMHints(dpy, c->win)))
dwm.c:	XSetWMHints(dpy, c->win, wmh);
dwm.c:		XMoveWindow(dpy, c->win, c->x, c->y);
dwm.c:		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
dwm.c:			resize(c, c->x, c->y, c->w, c->h, 0);
dwm.c:		showhide(c->snext);
dwm.c:		showhide(c->snext);
dwm.c:		XMoveWindow(dpy, c->win, WIDTH(c) * -2, c->y);
dwm.c:	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
dwm.c:	for (i = 0, my = ty = m->gappoh*oe, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
dwm.c:			resize(c, m->wx + m->gappov*oe, m->wy + my, mw - (2*c->bw) - m->gappiv*ie, h - (2*c->bw), 0);
dwm.c:			resize(c, m->wx + mw + m->gappov*oe, m->wy + ty, m->ww - mw - (2*c->bw) - 2*m->gappov*oe, h - (2*c->bw), 0);
dwm.c:	XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
dwm.c:	Monitor *m = c->mon;
dwm.c:	if (c->swallowing) {
dwm.c:	Client *s = swallowingclient(c->win);
dwm.c:		wc.border_width = c->oldbw;
dwm.c:		XConfigureWindow(dpy, c->win, CWBorderWidth, &wc); /* restore border */
dwm.c:		XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
dwm.c:		for (c = m->clients; c; c = c->next)
dwm.c:				(unsigned char *) &(c->win), 1);
dwm.c:					m->clients = c->next;
dwm.c:					c->mon = mons;
dwm.c:	if (!XGetWMNormalHints(dpy, c->win, &size, &msize))
dwm.c:		c->basew = size.base_width;
dwm.c:		c->baseh = size.base_height;
dwm.c:		c->basew = size.min_width;
dwm.c:		c->baseh = size.min_height;
dwm.c:		c->basew = c->baseh = 0;
dwm.c:		c->incw = size.width_inc;
dwm.c:		c->inch = size.height_inc;
dwm.c:		c->incw = c->inch = 0;
dwm.c:		c->maxw = size.max_width;
dwm.c:		c->maxh = size.max_height;
dwm.c:		c->maxw = c->maxh = 0;
dwm.c:		c->minw = size.min_width;
dwm.c:		c->minh = size.min_height;
dwm.c:		c->minw = size.base_width;
dwm.c:		c->minh = size.base_height;
dwm.c:		c->minw = c->minh = 0;
dwm.c:		c->mina = (float)size.min_aspect.y / size.min_aspect.x;
dwm.c:		c->maxa = (float)size.max_aspect.x / size.max_aspect.y;
dwm.c:		c->maxa = c->mina = 0.0;
dwm.c:	c->isfixed = (c->maxw && c->maxh && c->maxw == c->minw && c->maxh == c->minh);
dwm.c:	if (!gettextprop(c->win, netatom[NetWMName], c->name, sizeof c->name))
dwm.c:		gettextprop(c->win, XA_WM_NAME, c->name, sizeof c->name);
dwm.c:	if (c->name[0] == '\0') /* hack to mark broken clients */
dwm.c:		strcpy(c->name, broken);
dwm.c:		c->isfloating = 1;
dwm.c:	if ((wmh = XGetWMHints(dpy, c->win))) {
dwm.c:			XSetWMHints(dpy, c->win, wmh);
dwm.c:			c->isurgent = (wmh->flags & XUrgencyHint) ? 1 : 0;
dwm.c:			c->neverfocus = !wmh->input;
dwm.c:			c->neverfocus = 0;
dwm.c:	v = proc->ki_ppid;
dwm.c:		for (c = m->clients; c; c = c->next) {
dwm.c:			if (c->isterminal && !c->swallowing && c->pid && isdescprocess(c->pid, w->pid))
dwm.c:		for (c = m->clients; c; c = c->next) {
dwm.c:			if (c->swallowing && c->swallowing->win == w)
dwm.c:		for (c = m->clients; c; c = c->next)
dwm.c:			if (c->win == w)
dwm.c:		return c->mon;
dwm.c:		if (!c || !(c = nexttiled(c->next)))
